/*
 * @Author: Ling
 * @Date: 2023-02-14 12:36:53
 * @LastEditors: Ling
 * @LastEditTime: 2023-05-25 18:27:09
 * @Description:
 */
import fs from 'fs';
import { debounce, isEqual, startCase } from 'lodash-es';
import path from 'path';

const fileObj = {
  watcher: undefined,
  fileList: [],
  pagesPath: path.resolve('./src/pages'),
  srcPath: path.resolve('./src'),
  routerFolder: path.resolve('./src/router'),
  routerPath: path.resolve('./src/router/router.tsx'),
  stamp: 0,
};

export default function routeScript() {
  return {
    name: 'routeScript',
    async buildStart() {
      await writeRoute();
      watchFiles();
    },
    buildEnd() {
      stopWatch();
    },
    closeBundle() {
      stopWatch();
    },
  };
}

async function writeRoute() {

  if (!fs.existsSync(fileObj.routerFolder)) {
    // 文件夹不存在，创建新文件夹
    fs.mkdirSync(fileObj.routerFolder);
    console.log(`文件夹创建成功`);
  }
  
  const t = Date.now();
  fileObj.stamp = t;
  const list = fileObj.fileList;
  const arr = (await fileDisplay(fileObj.pagesPath, t)) as Array<any>;
  arr.sort((a, b) => (a.name > b.name ? 1 : -1));
  if (isEqual(list, arr)) {
    return;
  }
  const fileList = arr;
  let content = `// @ts-nocheck
// This file is generated by Plugin automatically
// DO NOT CHANGE IT MANUALLY!

import { lazy } from 'react';

`;
  fileList.forEach((item) => {
    content += `export const ${item.name} = lazy(() => import('${item.path}'));
`;
  });
  fs.writeFile(fileObj.routerPath, content, function (err) {
    if (err) {
      console.error('写入 router 文件失败',err);
    }
  });
  console.log(new Date().toLocaleTimeString('en', { hour12: false }), '-------', 'wirte route');
  fileObj.fileList = fileList;
}

const writeRouteFn = debounce(writeRoute, 100);

function watchFiles() {
  fileObj.watcher = fs.watch(fileObj.pagesPath, { recursive: true }, (event, filename) => {
    if (event === 'change') {
      return;
    }
    if (/(\\components\\|\\component\\)/.test(filename)) {
      return;
    }
    writeRouteFn();
  });
}

function stopWatch() {
  console.log('stop watch');
  if (fileObj.watcher) {
    fileObj.watcher.close();
    fileObj.watcher = undefined;
  }
}

function fileDisplay(url, t) {
  let timer = null;
  const arr = [];
  return new Promise((resolve, reject) => {
    handle(url, t);
    function handle(url, t) {
      if (fileObj.stamp !== t) {
        reject();
        return;
      }
      const filePath = path.resolve(url);
      fs.readdir(filePath, (err, files) => {
        if (err) {
          return;
        }
        files.forEach((filename) => {
          if (
            filename === 'components' ||
            filename === 'component' ||
            // ['components', 'component'].includes(filename) ||
            filename.startsWith('_')
          ) {
            return;
          }
          const filedir = path.join(filePath, filename);
          fs.stat(filedir, (eror, stats) => {
            if (eror) {
              console.error('Error:(spec)', err);
              return;
            }
            const isFile = stats.isFile() && (filename.endsWith('tsx') || filedir.endsWith('jsx'));
            const isDir = stats.isDirectory();
            if (isFile) {
              const fpath = filedir.replace(fileObj.srcPath, '@').replace(/\\/g, '/');
              let fname = fpath.replace(/index.tsx$/, '').replace(/(^@\/pages|\.tsx$)/g, '');
              fname = startCase(fname).replace(/ /g, '');
              if (fileObj.stamp !== t) {
                return;
              }

              arr.push({ name: fname, path: fpath });

              if (fileObj.stamp !== t) {
                reject();
                return;
              }

              if (timer) {
                clearTimeout(timer);
              }
              timer = setTimeout(() => resolve(arr), 200);
            }
            if (isDir) handle(filedir, t);
          });
        });
      });
    }
  });
}
